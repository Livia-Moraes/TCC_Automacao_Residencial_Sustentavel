#include <ESP32Servo.h>        // Includes the library for controlling servos on the ESP32
#include <Arduino.h>           // Includes the main Arduino library for basic functionalities
#include <WiFi.h>              // Includes the library for Wi-Fi control
#include <UniversalTelegramBot.h> // Includes the library for communication with Telegram
#include <WiFiClientSecure.h>  // Includes the library for secure Wi-Fi connections

// Wi-Fi Data
const char* ssid = "Livia";    // Defines the name of the Wi-Fi network (SSID)
const char* password = "Flamengo2019"; // Defines the password for the Wi-Fi network

// Bot Data
const char* telegramToken = "7611180026:AAH4S1qSRjmUgW4i4qF01-LW7ftWeAfyDfo"; // Telegram bot token

const int ldrNortePin = 34;   // Defines the analog pin for the North LDR
const int ldrSulPin = 35;     // Defines the analog pin for the South LDR
const int ldrLestePin = 32;   // Defines the analog pin for the East LDR
const int ldrOestePin = 33;   // Defines the analog pin for the West LDR
const int limiar = 1000;   // Minimum value to detect sufficient light
const int neutrolimiar = 500; // Value for the neutral position

Servo servoNS;                // Creates the North-South servo object
Servo servoLO;                // Creates the East-West servo object

int posicaoAtualNS = 90;      // Initial position for the North-South servo
int posicaoAtualLO = 90;      // Initial position for the East-West servo

// Telegram Configuration
WiFiClientSecure client;      // Creates the secure Wi-Fi client
UniversalTelegramBot bot(telegramToken, client); // Initializes the bot with the token and client
unsigned long bot_lasttime = 0; // Variable to store the last update time of the bot
const int botRequestDelay = 1000;  // Delay between bot requests (in milliseconds)

void setup() {
  Serial.begin(9600);          // Starts serial communication at 9600 baud rate

  // Wi-Fi Configuration
  WiFi.begin(ssid, password);  // Connects to the Wi-Fi with the defined SSID and password
  while (WiFi.status() != WL_CONNECTED) { // Wait until connected
    delay(500);
    Serial.print(".");         // Prints "." while trying to connect
  }
  Serial.println("Conectado ao WiFi"); // Informs that the connection is established

  // Configures SSL certificate check bypass
  client.setInsecure();        // Disables certificate verification for SSL connections

  // Servo Configuration
  servoNS.attach(14);          // Connects the North-South servo to GPIO14
  servoLO.attach(12);          // Connects the East-West servo to GPIO12

  // Sets initial positions of the servos
  servoNS.write(posicaoAtualNS);  
  servoLO.write(posicaoAtualLO);
  delay(3000);                 // Waits 3 seconds for stabilization
}

// Function to move the servo slowly to the final position
void moverServoLento(Servo &servo, int &posicaoAtual, int posicaoFinal) {
  if (posicaoAtual != posicaoFinal) { // Checks if the final position is different from the current one
    if (posicaoAtual < posicaoFinal) { // For increasing movement
      for (int pos = posicaoAtual; pos <= posicaoFinal; pos++) {
        servo.write(pos);        // Adjusts the servo to the position
        delay(20);               // Waits 20 ms between movements
      }
    } else {                     // For decreasing movement
      for (int pos = posicaoAtual; pos >= posicaoFinal; pos--) {
        servo.write(pos);
        delay(20);  
      }
    }
    posicaoAtual = posicaoFinal; // Updates the current position
  }
}

// Function to handle new messages
void handleNewMessages(int numNewMessages) {
  for (int i = 0; i < numNewMessages; i++) { // Loops through all new received messages
    String chat_id = String(bot.messages[i].chat_id); // Stores the chat ID
    String text = bot.messages[i].text; // Stores the message text

    String resposta;
    if (text == "/start") {
      resposta = "Bem-vindo! Use /ajuda para ver os comandos disponíveis.";
    } else if (text == "/informacao") {
      resposta = "O rastreador solar foi projetado pensando na melhora da eficiência energética da geração de energia, com as posições do painel sendo ajustadas de acordo com a intensidade da luz solar no sensor de luminosidade.\n"
           "Para que seja possível ter mais autonomia na sua geração, você pode calcular a quantidade de energia gerada por um painel usando a fórmula: (Energia (kWh) = Potência do Painel (kW) * Irradiação Solar (kWh/m².dia) * Eficiência * Dias).\n"
           "A irradiação solar varia de acordo com cada região e isso deve ser levado em conta. Para mais informações detalhadas sobre como fazer esse cálculo, consulte: https://blog.solfacil.com.br/energia-solar/como-calcular-a-energia-gerada-por-um-painel-solar/";

    } else if (text == "/porcentagem_norte") {
      int ldrNorteValue = analogRead(ldrNortePin);
      resposta = "Porcentagem Norte: " + String((ldrNorteValue * 100) / 4095) + "%";
    } else if (text == "/porcentagem_sul") {
      int ldrSulValue = analogRead(ldrSulPin);
      resposta = "Porcentagem Sul: " + String((ldrSulValue * 100) / 4095) + "%";
    } else if (text == "/porcentagem_leste") {
      int ldrLesteValue = analogRead(ldrLestePin);
      resposta = "Porcentagem Leste: " + String((ldrLesteValue * 100) / 4095) + "%";
    } else if (text == "/porcentagem_oeste") {
      int ldrOesteValue = analogRead(ldrOestePin);
      resposta = "Porcentagem Oeste: " + String((ldrOesteValue * 100) / 4095) + "%";
    } else if (text == "/ambos") {
      int ldrNorteValue = analogRead(ldrNortePin);
      int ldrSulValue = analogRead(ldrSulPin);
      int ldrLesteValue = analogRead(ldrLestePin);
      int ldrOesteValue = analogRead(ldrOestePin);
      resposta = "Porcentagem Norte: " + String((ldrNorteValue * 100) / 4095) + "%\n" +
           "Porcentagem Sul: " + String((ldrSulValue * 100) / 4095) + "%\n" +
           "Porcentagem Leste: " + String((ldrLesteValue * 100) / 4095) + "%\n" +
           "Porcentagem Oeste: " + String((ldrOesteValue * 100) / 4095) + "%";

    } else if (text == "/ajuda") {
      resposta = "Comandos disponíveis:\n"
           "/start - Iniciar o bot\n"
           "/informacao - Informações sobre o bot\n"
           "/porcentagem_norte - Percentagem Norte\n"
           "/porcentagem_sul - Percentagem Sul\n"
           "/porcentagem_leste - Percentagem Leste\n"
           "/porcentagem_oeste - Percentagem Oeste\n"
           "/ambos - Norte, Sul, Leste e Oeste\n"
           "/ajuda - Lista de comandos";

    } else {
      resposta = "Comando não reconhecido.";
    }

    bot.sendMessage(chat_id, resposta, ""); // Sends the response via the bot
  }
}

void loop() {
  // Reads the values from the LDRs and controls the servos
  int ldrNorteValue = analogRead(ldrNortePin); // Reads the North LDR
  int ldrSulValue = analogRead(ldrSulPin);     // Reads the South LDR
  int ldrLesteValue = analogRead(ldrLestePin); // Reads the East LDR
  int ldrOesteValue = analogRead(ldrOestePin); // Reads the West LDR

  // Controls the North-South servo based on LDR values
  if (ldrNorteValue > limiar && ldrNorteValue > ldrSulValue) {
    Serial.println("Luz detectada no Norte");
    moverServoLento(servoNS, posicaoAtualNS, 40); // Position for north
  } else if (ldrSulValue > limiar && ldrSulValue > ldrNorteValue) {
    Serial.println("Luz detectada no Sul");
    moverServoLento(servoNS, posicaoAtualNS, 180); // Position for south
  } else if (ldrNorteValue < neutrolimiar && ldrSulValue < neutrolimiar) {
    Serial.println("Luz insuficiente - posição neutra");
    moverServoLento(servoNS, posicaoAtualNS, 90); // Neutral position for NS
  }

  // Controls the East-West servo based on LDR values
  if (ldrLesteValue > limiar && ldrLesteValue > ldrOesteValue) {
    Serial.println("Luz detectada no Leste");
    moverServoLento(servoLO, posicaoAtualLO, 0); // Position for east
  } else if (ldrOesteValue > limiar && ldrOesteValue > ldrLesteValue) {
    Serial.println("Luz detectada no Oeste");
    moverServoLento(servoLO, posicaoAtualLO, 180); // Position for west
  } else if (ldrLesteValue < neutrolimiar && ldrOesteValue < neutrolimiar) {
    Serial.println("Luz insuficiente - posição neutra");
    moverServoLento(servoLO, posicaoAtualLO, 90); // Neutral position for LO
  }

  // Handles any new messages from Telegram
  if (millis() - bot_lasttime > botRequestDelay) {
    int numNewMessages = bot.getUpdates(bot_lasttime); // Gets new messages from Telegram
    if (numNewMessages) {
      handleNewMessages(numNewMessages); // Process the new messages
      bot_lasttime = millis(); // Updates the last time for the bot
    }
  }
}
